這兩張簡報圖說明的是「**保持函數依賴的模式分解——合成法（Synthesis）將 R(U, F) 轉為 3NF 的演算法 6.2**」，這是資料庫理論中非常重要的一步，目的是把關係模式轉換為第三范式（3NF），**又保留所有原始的函數依賴**。以下是逐步說明：

---

## ✅ 算法 6.2（合成法）說明：將 R(U, F) 分解為保持函數依賴的 3NF

---

### 🔵 步驟 ①：最小化函數依賴集 F

對於 R(U, F)，先對 F 進行**極小化交處理**（即計算 F 的最小覆蓋集 Fmin）：
- 包括：右邊拆單一屬性、刪除冗餘屬性與冗餘依賴。

**目標：** 為後續建立候選鍵與分解做準備。

---

### 🔵 步驟 ②：處理不出現在 F 的屬性

找出 **不在任何函數依賴中出現**的屬性（記為 U₀），並構造一個獨立的關係模式：
- R₀(U₀, ∅)，只包含孤立屬性。
- 再把這些屬性從 U 中刪除，剩下的記為新的 U。

**目的：** 確保資料庫中每個屬性都能保留下來，避免遺失。

---

### 🔵 步驟 ③：若某個依賴覆蓋整個 U，則不需分解

若存在某個依賴 `X → A` ∈ F，使得 `X ∪ {A} = U`，則整個關係已經覆蓋全部屬性，無需再分解：
- ρ = {R}，算法結束。

---

## 🔵 步驟 ④：進行實際的合成分解

若無法一步完成，進入這一步驟：

---

### ✅ 對 F 進行分組（依照左部相同的函數依賴）

- 假設分為 k 組（同一組的依賴左邊相同），每組形成一個屬性集 Uᵢ（包含左邊與右邊出現的所有屬性）。
- 為每組建立一個關係模式 Rᵢ(Uᵢ, Fᵢ)

👉 注意：如果某個 Uᵢ 是另一個 Uⱼ 的子集，就可以刪除這個子集以精簡結構。

---

### ✅ 最終分解結果為：

\[
ρ = \{ R₁(U₁, F₁), R₂(U₂, F₂), ..., R_k(U_k, F_k) \} ∪ R₀(U₀, ∅)
\]

- 每一個 Rᵢ 是一個 3NF 模式（透過極小化與拆分確保）
- 所有 Fᵢ 是函數依賴集 F 在 Uᵢ 上的**投影**
- 保證 **保持所有函數依賴**
- 且整個分解仍然是 lossless join（可無損重建）

---

## ✅ 小結圖解：

| 步驟 | 操作                              | 說明 |
|------|-----------------------------------|------|
| ①    | F 最小化                           | 刪冗餘依賴與冗餘屬性 |
| ②    | 抽離孤立屬性成 R₀                | 保留所有屬性 |
| ③    | 若有依賴覆蓋全部屬性，則不分解     | 直接結束 |
| ④    | 依左部相同分組依賴並建立 Rᵢ      | 每個 Rᵢ 滿足 3NF 且保持依賴 |
| 最後 | ρ = ⋃ 所有 Rᵢ ∪ R₀                | 得到完整保持依賴的 3NF 分解 |

---
